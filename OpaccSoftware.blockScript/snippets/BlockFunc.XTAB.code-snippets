{
	"BLOCKFUNC: XTAB.AddCol":	{
		"prefix":	"üîê  BlockFunc.XTAB.AddCol",
		"description":	["Spalte hinzuf√ºgen. Zur√ºckgegeben wird Nummer der eingef√ºgten Spalte. Aktuell unterst√ºtzt werden die Datentypen 'A', 'B', 'D' und 'R'. Standardm√§ssig (ohne n√§here Angabe) wird eine 'A'-Spalte erstellt."],
		"body":	[
			"\tvar ${1:numberVal} := XTAB.AddCol(${2:xTabName}, ${3:colName}, ${4:colDataTypeAndFormat})",		]
	},
	"BLOCKFUNC: XTAB.AddIndexByColNames":	{
		"prefix":	"üîê  BlockFunc.XTAB.AddIndexByColNames",
		"description":	["Index (Unique-Constraint) anhand der √ºbergebenen Spalten-Namen hinzuf√ºgen. Zur√ºckgegeben wird Index-Nummer. ACHTUNG: Kann bei Tabellen mit vielen Zeilen langsam sein!"],
		"body":	[
			"\tvar ${1:numberVal} := XTAB.AddIndexByColNames(${2:xTabName}, ${3:colNames})",		]
	},
	"BLOCKFUNC: XTAB.AddIndexByColNos":	{
		"prefix":	"üîê  BlockFunc.XTAB.AddIndexByColNos",
		"description":	["Index (Unique-Constraint) anhand der √ºbergebenen Spalten-Nummern hinzuf√ºgen. Zur√ºckgegeben wird Index-Nummer. ACHTUNG: Kann bei Tabellen mit vielen Zeilen langsam sein!"],
		"body":	[
			"\tvar ${1:numberVal} := XTAB.AddIndexByColNos(${2:xTabName}, ${3:oneBasedColNos})",		]
	},
	"BLOCKFUNC: XTAB.AddRow":	{
		"prefix":	"üîê  BlockFunc.XTAB.AddRow",
		"description":	["Zus√§tzliche Zeile hinzuf√ºgen, wobei die Spalten-Werte optional mitgegeben werden k√∂nnen. Fehler, wenn Constraint-Violation (√ºblicherweise Unique-Index-Verletzung). Fehler, wenn einer der √ºbergebenen Werte nicht passt und auch nicht umgewandelt werden kann."],
		"body":	[
			"XTAB.AddRow(${2:xTabName}, ${3:values})",		]
	},
	"BLOCKFUNC: XTAB.AddRowAndReturnNo":	{
		"prefix":	"üîê  BlockFunc.XTAB.AddRowAndReturnNo",
		"description":	["Zus√§tzliche Zeile hinzuf√ºgen, wobei die Spalten-Werte optional mitgegeben werden k√∂nnen. Fehler, wenn Constraint-Violation (√ºblicherweise Unique-Index-Verletzung). Fehler, wenn einer der √ºbergebenen Werte nicht passt und auch nicht umgewandelt werden kann. Zur√ºckgegeben wird die Nummer der neu eingef√ºgten Row (wenn diese gem√§ss allf√§llig vorhandenem Filter sichtbar ist - ansonsten 0). ACHTUNG: Kann bei Tabellen mit vielen Zeilen langsam sein!"],
		"body":	[
			"\tvar ${1:numberVal} := XTAB.AddRowAndReturnNo(${2:xTabName}, ${3:values})",		]
	},
	"BLOCKFUNC: XTAB.ClearView":	{
		"prefix":	"üîê  BlockFunc.XTAB.ClearView",
		"description":	["View (Filter und Sortierung) zur√ºcksetzen."],
		"body":	[
			"XTAB.ClearView(${2:xTabName})",		]
	},
	"BLOCKFUNC: XTAB.ClearViewFilter":	{
		"prefix":	"üîê  BlockFunc.XTAB.ClearViewFilter",
		"description":	["Filter zur√ºcksetzen. Zur√ºckgegeben wird die Anzahl Zeilen welche nach dem Entfernen des Filters sichtbar ist (alle Zeilen)."],
		"body":	[
			"\tvar ${1:numberVal} := XTAB.ClearViewFilter(${2:xTabName})",		]
	},
	"BLOCKFUNC: XTAB.ClearViewOrder":	{
		"prefix":	"üîê  BlockFunc.XTAB.ClearViewOrder",
		"description":	["Sortierreihenfolge zur√ºcksetzen."],
		"body":	[
			"XTAB.ClearViewOrder(${2:xTabName})",		]
	},
	"BLOCKFUNC: XTAB.CreateOrClear":	{
		"prefix":	"üîê  BlockFunc.XTAB.CreateOrClear",
		"description":	["Neue Tabelle definieren resp. bestehende Tabelle (Daten und Struktur) zur√ºcksetzen."],
		"body":	[
			"XTAB.CreateOrClear(${2:xTabName})",		]
	},
	"BLOCKFUNC: XTAB.DeleteRow":	{
		"prefix":	"üîê  BlockFunc.XTAB.DeleteRow",
		"description":	["Bestimmte Zeile l√∂schen (standardm√§ssig unter Einbezug einer allf√§lligen View). Fehler wenn adressierte Zeile nicht existiert."],
		"body":	[
			"XTAB.DeleteRow(${2:xTabName}, ${3:oneBasedRowNo}, ${4:withoutView})",		]
	},
	"BLOCKFUNC: XTAB.DeleteRows":	{
		"prefix":	"üîê  BlockFunc.XTAB.DeleteRows",
		"description":	["Alle Zeilen l√∂schen (standardm√§ssig unter Einbezug einer allf√§lligen View). Zur√ºckgegeben wird die Anzahl gel√∂schter Zeilen."],
		"body":	[
			"\tvar ${1:numberVal} := XTAB.DeleteRows(${2:xTabName}, ${3:withoutView})",		]
	},
	"BLOCKFUNC: XTAB.FindFirstRow":	{
		"prefix":	"üîê  BlockFunc.XTAB.FindFirstRow",
		"description":	["Liefert Nummer der ersten passenden Zeile. 0 wenn keine Zeile passt. √úbergebenes Filter wirkt (standardm√§ssig) additiv zu f√ºr ganze Tabelle gesetztem View-Filter (kann durch entsprechendes Argument √ºbersteuert werden). ACHTUNG: Kann bei Tabellen mit vielen Zeilen langsam sein!"],
		"body":	[
			"\tvar ${1:numberVal} := XTAB.FindFirstRow(${2:xTabName}, ${3:filterExpression}, ${4:withoutView})",		]
	},
	"BLOCKFUNC: XTAB.FindRowByIndex":	{
		"prefix":	"üîê  BlockFunc.XTAB.FindRowByIndex",
		"description":	["Liefert Nummer, der f√ºr die √ºbergebenen Index-Segmente passenden Zeile. 0 wenn keine Zeile passt. Allenfalls f√ºr Tabelle gesetzte View wird miteinbezogen, das heisst nur zu Filter passende Zeilen sind f√ºr Pr√ºfung relevant. ACHTUNG: Kann bei Tabellen mit vielen Zeilen langsam sein!"],
		"body":	[
			"\tvar ${1:numberVal} := XTAB.FindRowByIndex(${2:xTabName}, ${3:oneBasedIndexNo}, ${4:indexSegmentValues})",		]
	},
	"BLOCKFUNC: XTAB.FindRowByIndexWithoutView":	{
		"prefix":	"üîê  BlockFunc.XTAB.FindRowByIndexWithoutView",
		"description":	["Liefert Nummer, der f√ºr die √ºbergebenen Index-Segmente passenden Zeile. 0 wenn keine Zeile passt. Allenfalls f√ºr Tabelle gesetzte View wird _NICHT_ miteinbezogen, das heisst alle Zeilen sind f√ºr Pr√ºfung relevant. ACHTUNG: Kann bei Tabellen mit vielen Zeilen langsam sein!"],
		"body":	[
			"\tvar ${1:numberVal} := XTAB.FindRowByIndexWithoutView(${2:xTabName}, ${3:oneBasedIndexNo}, ${4:indexSegmentValues})",		]
	},
	"BLOCKFUNC: XTAB.GetBoolVal":	{
		"prefix":	"üîê  BlockFunc.XTAB.GetBoolVal",
		"description":	["Bestimmten Wert (standardm√§ssig unter Einbezug einer allf√§lligen View) als Boolean abholen. Fehler wenn Casting nicht m√∂glich ist. Standardm√§ssig Fehler, wenn adressierter Wert nicht vorhanden ist. Wenn dieser Fehler unterdr√ºckt wird, wird false geliefert."],
		"body":	[
			"\tvar ${1:boolVal} := XTAB.GetBoolVal(${2:xTabName}, ${3:oneBasedColNo}, ${4:oneBasedRowNo}, ${5:withoutView}, ${6:suppressExceptionIfNotAvailable})",		]
	},
	"BLOCKFUNC: XTAB.GetBoolValByColName":	{
		"prefix":	"üîê  BlockFunc.XTAB.GetBoolValByColName",
		"description":	["Bestimmten Wert (standardm√§ssig unter Einbezug einer allf√§lligen View) als Boolean abholen. Fehler wenn Casting nicht m√∂glich ist. Standardm√§ssig Fehler, wenn adressierter Wert nicht vorhanden ist. Wenn dieser Fehler unterdr√ºckt wird, wird false geliefert."],
		"body":	[
			"\tvar ${1:boolVal} := XTAB.GetBoolValByColName(${2:xTabName}, ${3:colName}, ${4:oneBasedRowNo}, ${5:withoutView}, ${6:suppressExceptionIfNotAvailable})",		]
	},
	"BLOCKFUNC: XTAB.GetColDataTypeAndFormatByName":	{
		"prefix":	"üîê  BlockFunc.XTAB.GetColDataTypeAndFormatByName",
		"description":	["Liefert Spalten-Datentyp und Format zum √ºbergebenen Spalten-Namen. Standardm√§ssig Fehler, wenn nicht vorhanden. Andernfalls Leerstring."],
		"body":	[
			"\tvar ${1:stringVal} := XTAB.GetColDataTypeAndFormatByName(${2:xTabName}, ${3:colName}, ${4:suppressExceptionIfNotAvailable})",		]
	},
	"BLOCKFUNC: XTAB.GetColDataTypeAndFormatByNo":	{
		"prefix":	"üîê  BlockFunc.XTAB.GetColDataTypeAndFormatByNo",
		"description":	["Liefert Spalten-Datentyp und Format zur √ºbergebenen Spalten-Nummer. Standardm√§ssig Fehler, wenn nicht vorhanden. Andernfalls Leerstring."],
		"body":	[
			"\tvar ${1:stringVal} := XTAB.GetColDataTypeAndFormatByNo(${2:xTabName}, ${3:oneBasedColNo}, ${4:suppressExceptionIfNotAvailable})",		]
	},
	"BLOCKFUNC: XTAB.GetColName":	{
		"prefix":	"üîê  BlockFunc.XTAB.GetColName",
		"description":	["Liefert Spalten-Namen zur √ºbergebenen Spalten-Nummer. Standardm√§ssig Fehler, wenn nicht vorhanden. Andernfalls Leerstring."],
		"body":	[
			"\tvar ${1:stringVal} := XTAB.GetColName(${2:xTabName}, ${3:oneBasedColNo}, ${4:suppressExceptionIfNotAvailable})",		]
	},
	"BLOCKFUNC: XTAB.GetColNo":	{
		"prefix":	"üîê  BlockFunc.XTAB.GetColNo",
		"description":	["Liefert Spalten-Nummer zum √ºbergebenen Spalten-Namen. Standardm√§ssig Fehler, wenn nicht vorhanden. Andernfalls 0."],
		"body":	[
			"\tvar ${1:numberVal} := XTAB.GetColNo(${2:xTabName}, ${3:colName}, ${4:suppressExceptionIfNotAvailable})",		]
	},
	"BLOCKFUNC: XTAB.GetDateVal":	{
		"prefix":	"üîê  BlockFunc.XTAB.GetDateVal",
		"description":	["Bestimmten Wert (standardm√§ssig unter Einbezug einer allf√§lligen View) als Datum abholen. Fehler wenn Casting nicht m√∂glich ist. Standardm√§ssig Fehler, wenn adressierter Wert nicht vorhanden ist. Wenn dieser Fehler unterdr√ºckt wird, wird 'Leer-Datum' (01.01.0001) geliefert."],
		"body":	[
			"\tvar ${1:dateVal} := XTAB.GetDateVal(${2:xTabName}, ${3:oneBasedColNo}, ${4:oneBasedRowNo}, ${5:withoutView}, ${6:suppressExceptionIfNotAvailable})",		]
	},
	"BLOCKFUNC: XTAB.GetDateValByColName":	{
		"prefix":	"üîê  BlockFunc.XTAB.GetDateValByColName",
		"description":	["Bestimmten Wert (standardm√§ssig unter Einbezug einer allf√§lligen View) als Datum abholen. Fehler wenn Casting nicht m√∂glich ist. Standardm√§ssig Fehler, wenn adressierter Wert nicht vorhanden ist. Wenn dieser Fehler unterdr√ºckt wird, wird 'Leer-Datum' (01.01.0001) geliefert."],
		"body":	[
			"\tvar ${1:dateVal} := XTAB.GetDateValByColName(${2:xTabName}, ${3:colName}, ${4:oneBasedRowNo}, ${5:withoutView}, ${6:suppressExceptionIfNotAvailable})",		]
	},
	"BLOCKFUNC: XTAB.GetNmbOfCols":	{
		"prefix":	"üîê  BlockFunc.XTAB.GetNmbOfCols",
		"description":	["Liefert Anzahl Spalten."],
		"body":	[
			"\tvar ${1:numberVal} := XTAB.GetNmbOfCols(${2:xTabName})",		]
	},
	"BLOCKFUNC: XTAB.GetNmbOfRows":	{
		"prefix":	"üîê  BlockFunc.XTAB.GetNmbOfRows",
		"description":	["Liefert Anzahl Zeilen (standardm√§ssig unter Einbezug einer allf√§lligen View)."],
		"body":	[
			"\tvar ${1:numberVal} := XTAB.GetNmbOfRows(${2:xTabName}, ${3:withoutView})",		]
	},
	"BLOCKFUNC: XTAB.GetNmbVal":	{
		"prefix":	"üîê  BlockFunc.XTAB.GetNmbVal",
		"description":	["Bestimmten Wert (standardm√§ssig unter Einbezug einer allf√§lligen View) als Zahl abholen. Fehler wenn Casting nicht m√∂glich ist. Standardm√§ssig Fehler, wenn adressierter Wert nicht vorhanden ist. Wenn dieser Fehler unterdr√ºckt wird, wird 0.0 geliefert."],
		"body":	[
			"\tvar ${1:numberVal} := XTAB.GetNmbVal(${2:xTabName}, ${3:oneBasedColNo}, ${4:oneBasedRowNo}, ${5:withoutView}, ${6:suppressExceptionIfNotAvailable})",		]
	},
	"BLOCKFUNC: XTAB.GetNmbValByColName":	{
		"prefix":	"üîê  BlockFunc.XTAB.GetNmbValByColName",
		"description":	["Bestimmten Wert (standardm√§ssig unter Einbezug einer allf√§lligen View) als Zahl abholen. Fehler wenn Casting nicht m√∂glich ist. Standardm√§ssig Fehler, wenn adressierter Wert nicht vorhanden ist. Wenn dieser Fehler unterdr√ºckt wird, wird 0.0 geliefert."],
		"body":	[
			"\tvar ${1:numberVal} := XTAB.GetNmbValByColName(${2:xTabName}, ${3:colName}, ${4:oneBasedRowNo}, ${5:withoutView}, ${6:suppressExceptionIfNotAvailable})",		]
	},
	"BLOCKFUNC: XTAB.GetRowByKey":	{
		"prefix":	"üîê  BlockFunc.XTAB.GetRowByKey",
		"description":	["Liefert Nummer einer Zeile gem√§ss Schl√ºssel-Werten oder 0 falls nicht vorhanden. Pr√ºfung in View (= nur Zeilen gem√§ss Filter). Sortierung gem√§ss Schl√ºssel muss aktiv sein! Auch f√ºr Tabellen mit vielen Zeilen schnell."],
		"body":	[
			"\tvar ${1:numberVal} := XTAB.GetRowByKey(${2:xTabName}, ${3:keySegmentValues})",		]
	},
	"BLOCKFUNC: XTAB.GetRowByKeyWithoutView":	{
		"prefix":	"üîê  BlockFunc.XTAB.GetRowByKeyWithoutView",
		"description":	["Liefert Nummer einer Zeile gem√§ss Schl√ºssel-Werten oder 0 falls nicht vorhanden. Pr√ºfung in ganzer Tabelle ohne View (= alle Zeilen). Auch f√ºr Tabellen mit vielen Zeilen schnell."],
		"body":	[
			"\tvar ${1:numberVal} := XTAB.GetRowByKeyWithoutView(${2:xTabName}, ${3:keySegmentValues})",		]
	},
	"BLOCKFUNC: XTAB.GetStrVal":	{
		"prefix":	"üîê  BlockFunc.XTAB.GetStrVal",
		"description":	["Bestimmten Wert (standardm√§ssig unter Einbezug einer allf√§lligen View) als String abholen. Fehler wenn Casting nicht m√∂glich ist. Standardm√§ssig Fehler, wenn adressierter Wert nicht vorhanden ist. Wenn dieser Fehler unterdr√ºckt wird, wird '' (Leerstring) geliefert."],
		"body":	[
			"\tvar ${1:stringVal} := XTAB.GetStrVal(${2:xTabName}, ${3:oneBasedColNo}, ${4:oneBasedRowNo}, ${5:withoutView}, ${6:suppressExceptionIfNotAvailable})",		]
	},
	"BLOCKFUNC: XTAB.GetStrValByColName":	{
		"prefix":	"üîê  BlockFunc.XTAB.GetStrValByColName",
		"description":	["Bestimmten Wert (standardm√§ssig unter Einbezug einer allf√§lligen View) als String abholen. Fehler wenn Casting nicht m√∂glich ist. Standardm√§ssig Fehler, wenn adressierter Wert nicht vorhanden ist. Wenn dieser Fehler unterdr√ºckt wird, wird '' (Leerstring) geliefert."],
		"body":	[
			"\tvar ${1:stringVal} := XTAB.GetStrValByColName(${2:xTabName}, ${3:colName}, ${4:oneBasedRowNo}, ${5:withoutView}, ${6:suppressExceptionIfNotAvailable})",		]
	},
	"BLOCKFUNC: XTAB.GetViewFilter":	{
		"prefix":	"üîê  BlockFunc.XTAB.GetViewFilter",
		"description":	["Aktuellen Filter abholen."],
		"body":	[
			"\tvar ${1:stringVal} := XTAB.GetViewFilter(${2:xTabName})",		]
	},
	"BLOCKFUNC: XTAB.HasColWithName":	{
		"prefix":	"üîê  BlockFunc.XTAB.HasColWithName",
		"description":	["Pr√ºfen ob Spalte mit dem √ºbergebenen Namen vorhanden ist."],
		"body":	[
			"\tvar ${1:boolVal} := XTAB.HasColWithName(${2:xTabName}, ${3:colName})",		]
	},
	"BLOCKFUNC: XTAB.HasColWithNo":	{
		"prefix":	"üîê  BlockFunc.XTAB.HasColWithNo",
		"description":	["Pr√ºfen ob Spalte mit der √ºbergebenen Nummer vorhanden ist."],
		"body":	[
			"\tvar ${1:boolVal} := XTAB.HasColWithNo(${2:xTabName}, ${3:oneBasedColNo})",		]
	},
	"BLOCKFUNC: XTAB.HasIndex":	{
		"prefix":	"üîê  BlockFunc.XTAB.HasIndex",
		"description":	["Pr√ºfen ob Index mit der √ºbergebenen Nummer vorhanden ist."],
		"body":	[
			"\tvar ${1:boolVal} := XTAB.HasIndex(${2:xTabName}, ${3:oneBasedIndexNo})",		]
	},
	"BLOCKFUNC: XTAB.HasKey":	{
		"prefix":	"üîê  BlockFunc.XTAB.HasKey",
		"description":	["Pr√ºfen ob ein Key definiert ist."],
		"body":	[
			"\tvar ${1:boolVal} := XTAB.HasKey(${2:xTabName})",		]
	},
	"BLOCKFUNC: XTAB.HasRowByIndex":	{
		"prefix":	"üîê  BlockFunc.XTAB.HasRowByIndex",
		"description":	["Pr√ºft, ob bereits eine Zeile f√ºr die √ºbergebenen Index-Segmente vorhanden ist. Allenfalls f√ºr Tabelle gesetzte View- wird miteinbezogen, das heisst nur zu Filter passende Zeilen sind f√ºr Pr√ºfung relevant. ACHTUNG: Kann bei Tabellen mit vielen Zeilen langsam sein!"],
		"body":	[
			"\tvar ${1:boolVal} := XTAB.HasRowByIndex(${2:xTabName}, ${3:oneBasedIndexNo}, ${4:indexSegmentValues})",		]
	},
	"BLOCKFUNC: XTAB.HasRowByIndexWithoutView":	{
		"prefix":	"üîê  BlockFunc.XTAB.HasRowByIndexWithoutView",
		"description":	["Pr√ºft, ob bereits eine Zeile f√ºr die √ºbergebenen Index-Segmente vorhanden ist. Allenfalls f√ºr Tabelle gesetzte View wird NICHT miteinbezogen, das heisst alle Zeilen sind f√ºr Pr√ºfung relevant. ACHTUNG: Kann bei Tabellen mit vielen Zeilen langsam sein!"],
		"body":	[
			"\tvar ${1:boolVal} := XTAB.HasRowByIndexWithoutView(${2:xTabName}, ${3:oneBasedIndexNo}, ${4:indexSegmentValues})",		]
	},
	"BLOCKFUNC: XTAB.HasRowByKey":	{
		"prefix":	"üîê  BlockFunc.XTAB.HasRowByKey",
		"description":	["Ist eine bestimmte Zeile gem√§ss Schl√ºssel-Werten bereits vorhanden? Pr√ºfung in View (= nur Zeilen gem√§ss Filter). Sortierung gem√§ss Schl√ºssel muss aktiv sein! Auch f√ºr Tabellen mit vielen Zeilen schnell."],
		"body":	[
			"\tvar ${1:boolVal} := XTAB.HasRowByKey(${2:xTabName}, ${3:keySegmentValues})",		]
	},
	"BLOCKFUNC: XTAB.HasRowByKeyWithoutView":	{
		"prefix":	"üîê  BlockFunc.XTAB.HasRowByKeyWithoutView",
		"description":	["Ist eine bestimmte Zeile gem√§ss Schl√ºssel-Werten bereits vorhanden? Pr√ºfung in ganzer Tabelle ohne View (= alle Zeilen). Auch f√ºr Tabellen mit vielen Zeilen schnell."],
		"body":	[
			"\tvar ${1:boolVal} := XTAB.HasRowByKeyWithoutView(${2:xTabName}, ${3:keySegmentValues})",		]
	},
	"BLOCKFUNC: XTAB.IsDefined":	{
		"prefix":	"üîê  BlockFunc.XTAB.IsDefined",
		"description":	["Ermittelt, ob eine bestimmte Tabelle existiert."],
		"body":	[
			"\tvar ${1:boolVal} := XTAB.IsDefined(${2:xTabName})",		]
	},
	"BLOCKFUNC: XTAB.SetKeyByColNames":	{
		"prefix":	"üîê  BlockFunc.XTAB.SetKeyByColNames",
		"description":	["Schl√ºssel gem√§ss den √ºbergebenen Spalten setzen. Definiert automatisch einen 'Unique - Constraint'. ACHTUNG: Kann bei Tabellen mit vielen Zeilen langsam sein!"],
		"body":	[
			"XTAB.SetKeyByColNames(${2:xTabName}, ${3:colNames})",		]
	},
	"BLOCKFUNC: XTAB.SetKeyByColNos":	{
		"prefix":	"üîê  BlockFunc.XTAB.SetKeyByColNos",
		"description":	["Schl√ºssel gem√§ss den √ºbergebenen Spalten setzen. Definiert automatisch einen 'Unique - Constraint'. ACHTUNG: Kann bei Tabellen mit vielen Zeilen langsam sein!"],
		"body":	[
			"XTAB.SetKeyByColNos(${2:xTabName}, ${3:oneBasedColNos})",		]
	},
	"BLOCKFUNC: XTAB.SetVal":	{
		"prefix":	"üîê  BlockFunc.XTAB.SetVal",
		"description":	["Einen Wert setzen (standardm√§ssig unter Einbezug einer allf√§lligen View). Fehler, wenn Constraint-Violation (√ºblicherweise Unique-Index-Verletzung). Fehler, wenn √ºbergebener Wert nicht zur adressierten Spalte passt und auch nicht umgewandelt werden kann. Standardm√§ssig Fehler, wenn Spalte oder Zeile nicht existiert. R√ºckgabewert besagt, ob Wert gesetzt wurde oder nicht."],
		"body":	[
			"\tvar ${1:boolVal} := XTAB.SetVal(${2:xTabName}, ${3:oneBasedColNo}, ${4:oneBasedRowNo}, ${5:value}, ${6:withoutView}, ${7:suppressExceptionIfNotAvailable})",		]
	},
	"BLOCKFUNC: XTAB.SetValByColName":	{
		"prefix":	"üîê  BlockFunc.XTAB.SetValByColName",
		"description":	["Einen Wert setzen (standardm√§ssig unter Einbezug einer allf√§lligen View). Fehler, wenn Constraint-Violation (√ºblicherweise Unique-Index-Verletzung). Fehler, wenn √ºbergebener Wert nicht zur adressierten Spalte passt und auch nicht umgewandelt werden kann. Standardm√§ssig Fehler, wenn Spalte oder Zeile nicht existiert. R√ºckgabewert besagt, ob Wert gesetzt wurde oder nicht."],
		"body":	[
			"\tvar ${1:boolVal} := XTAB.SetValByColName(${2:xTabName}, ${3:colName}, ${4:oneBasedRowNo}, ${5:value}, ${6:withoutView}, ${7:suppressExceptionIfNotAvailable})",		]
	},
	"BLOCKFUNC: XTAB.SetViewFilter":	{
		"prefix":	"üîê  BlockFunc.XTAB.SetViewFilter",
		"description":	["Einen Filter setzen: Nach dem Setzen ist nur noch ein Subset der Zeilen sichtbar. Zur√ºckgegeben, wird die Anzahl der 'sichtbaren' Zeilen. ACHTUNG: Kann bei Tabellen mit vielen Zeilen langsam sein!"],
		"body":	[
			"\tvar ${1:numberVal} := XTAB.SetViewFilter(${2:xTabName}, ${3:filterExpression})",		]
	},
	"BLOCKFUNC: XTAB.SetViewOrderByColNames":	{
		"prefix":	"üîê  BlockFunc.XTAB.SetViewOrderByColNames",
		"description":	["Sortierreihenfolge gem√§ss den √ºbergebenen Spalten-Namen setzen. Prefix '-' = absteigende Sortierung. ACHTUNG: Kann bei Tabellen mit vielen Zeilen langsam sein!"],
		"body":	[
			"XTAB.SetViewOrderByColNames(${2:xTabName}, ${3:colNames})",		]
	},
	"BLOCKFUNC: XTAB.SetViewOrderByColNos":	{
		"prefix":	"üîê  BlockFunc.XTAB.SetViewOrderByColNos",
		"description":	["Sortierreihenfolge gem√§ss den √ºbergebenen Spalten-Nummern setzen. Negative Nummern = absteigende Sortierung. ACHTUNG: Kann bei Tabellen mit vielen Zeilen langsam sein!"],
		"body":	[
			"XTAB.SetViewOrderByColNos(${2:xTabName}, ${3:oneBasedColNos})",		]
	},
	"BLOCKFUNC: XTAB.SetViewOrderByIndex":	{
		"prefix":	"üîê  BlockFunc.XTAB.SetViewOrderByIndex",
		"description":	["Sortierreihenfolge gem√§ss Index setzen. Fehler wenn Index nicht vorhanden ist. ACHTUNG: Kann bei Tabellen mit vielen Zeilen langsam sein!"],
		"body":	[
			"XTAB.SetViewOrderByIndex(${2:xTabName}, ${3:oneBasedIndexNo})",		]
	},
	"BLOCKFUNC: XTAB.SetViewOrderByKey":	{
		"prefix":	"üîê  BlockFunc.XTAB.SetViewOrderByKey",
		"description":	["Sortierreihenfolge gem√§ss Schl√ºssel setzen. Fehler wenn Schl√ºssel nicht definiert wurde."],
		"body":	[
			"XTAB.SetViewOrderByKey(${2:xTabName})",		]
	},
	"BLOCKFUNC: XTAB.TryAddRow":	{
		"prefix":	"üîê  BlockFunc.XTAB.TryAddRow",
		"description":	["Zus√§tzliche Zeile hinzuf√ºgen, wobei die Spalten-Werte optional mitgegeben werden k√∂nnen. Im Constraint-Violation-Fehlerfall (√ºblicherweise Unique-Index-Verletzung) wird nicht eingef√ºgt und false zur√ºckgegeben. Wenn einer der √ºbergebenen Werte nicht passt und auch nicht umgewandelt werden kann, wird nicht eingef√ºgt und false zur√ºckgegeben. Wenn erfolgreich eingef√ºgt werden kann, wird true zur√ºckgegeben."],
		"body":	[
			"\tvar ${1:boolVal} := XTAB.TryAddRow(${2:xTabName}, ${3:values})",		]
	},
	"BLOCKFUNC: XTAB.TryAddRowAndReturnNo":	{
		"prefix":	"üîê  BlockFunc.XTAB.TryAddRowAndReturnNo",
		"description":	["Zus√§tzliche Zeile hinzuf√ºgen, wobei die Spalten-Werte optional mitgegeben werden k√∂nnen. Zur√ºckgegeben wird die Nummer der neu eingef√ºgten Row (wenn diese gem√§ss allf√§llig vorhandenem Filter sichtbar ist - ansonsten 0). Im Constraint-Violation-Fehlerfall (√ºblicherweise Unique-Index-Verletzung) wird nicht eingef√ºgt und -1 zur√ºckgegeben. Wenn einer der √ºbergebenen Werte nicht passt und auch nicht umgewandelt werden kann, wird nicht eingef√ºgt und -2 zur√ºckgegeben. ACHTUNG: Kann bei Tabellen mit vielen Zeilen langsam sein!"],
		"body":	[
			"\tvar ${1:numberVal} := XTAB.TryAddRowAndReturnNo(${2:xTabName}, ${3:values})",		]
	},
	"BLOCKFUNC: XTAB.TryGetBoolVal":	{
		"prefix":	"üîê  BlockFunc.XTAB.TryGetBoolVal",
		"description":	["Bestimmten Wert (standardm√§ssig unter Einbezug einer allf√§lligen View) als Boolean abholen. Wenn Casting nicht m√∂glich ist, wird false zur√ºckgegeben. Standardm√§ssig Fehler, wenn adressierter Wert nicht vorhanden ist. Wenn dieser Fehler unterdr√ºckt wird, wird false geliefert."],
		"body":	[
			"\tvar ${1:boolVal} := XTAB.TryGetBoolVal(${2:xTabName}, ${3:oneBasedColNo}, ${4:oneBasedRowNo}, ${5:withoutView}, ${6:suppressExceptionIfNotAvailable})",		]
	},
	"BLOCKFUNC: XTAB.TryGetBoolValByColName":	{
		"prefix":	"üîê  BlockFunc.XTAB.TryGetBoolValByColName",
		"description":	["Bestimmten Wert (standardm√§ssig unter Einbezug einer allf√§lligen View) als Boolean abholen. Wenn Casting nicht m√∂glich ist, wird false zur√ºckgegeben. Standardm√§ssig Fehler, wenn adressierter Wert nicht vorhanden ist. Wenn dieser Fehler unterdr√ºckt wird, wird false geliefert."],
		"body":	[
			"\tvar ${1:boolVal} := XTAB.TryGetBoolValByColName(${2:xTabName}, ${3:colName}, ${4:oneBasedRowNo}, ${5:withoutView}, ${6:suppressExceptionIfNotAvailable})",		]
	},
	"BLOCKFUNC: XTAB.TryGetDateVal":	{
		"prefix":	"üîê  BlockFunc.XTAB.TryGetDateVal",
		"description":	["Bestimmten Wert (standardm√§ssig unter Einbezug einer allf√§lligen View) als Datum abholen. Wenn Casting nicht m√∂glich ist, wird 'Leer-Datum' (01.01.0001) zur√ºckgegeben. Standardm√§ssig Fehler, wenn adressierter Wert nicht vorhanden ist. Wenn dieser Fehler unterdr√ºckt wird, wird 'Leer-Datum' (01.01.0001) geliefert."],
		"body":	[
			"\tvar ${1:dateVal} := XTAB.TryGetDateVal(${2:xTabName}, ${3:oneBasedColNo}, ${4:oneBasedRowNo}, ${5:withoutView}, ${6:suppressExceptionIfNotAvailable})",		]
	},
	"BLOCKFUNC: XTAB.TryGetDateValByColName":	{
		"prefix":	"üîê  BlockFunc.XTAB.TryGetDateValByColName",
		"description":	["Bestimmten Wert (standardm√§ssig unter Einbezug einer allf√§lligen View) als Datum abholen. Wenn Casting nicht m√∂glich ist, wird 'Leer-Datum' (01.01.0001) zur√ºckgegeben. Standardm√§ssig Fehler, wenn adressierter Wert nicht vorhanden ist. Wenn dieser Fehler unterdr√ºckt wird, wird 'Leer-Datum' (01.01.0001) geliefert."],
		"body":	[
			"\tvar ${1:dateVal} := XTAB.TryGetDateValByColName(${2:xTabName}, ${3:colName}, ${4:oneBasedRowNo}, ${5:withoutView}, ${6:suppressExceptionIfNotAvailable})",		]
	},
	"BLOCKFUNC: XTAB.TryGetNmbVal":	{
		"prefix":	"üîê  BlockFunc.XTAB.TryGetNmbVal",
		"description":	["Bestimmten Wert (standardm√§ssig unter Einbezug einer allf√§lligen View) als Zahl abholen. Wenn Casting nicht m√∂glich ist, wird 0.0 zur√ºckgegeben. Standardm√§ssig Fehler, wenn adressierter Wert nicht vorhanden ist. Wenn dieser Fehler unterdr√ºckt wird, wird 0.0 geliefert."],
		"body":	[
			"\tvar ${1:numberVal} := XTAB.TryGetNmbVal(${2:xTabName}, ${3:oneBasedColNo}, ${4:oneBasedRowNo}, ${5:withoutView}, ${6:suppressExceptionIfNotAvailable})",		]
	},
	"BLOCKFUNC: XTAB.TryGetNmbValByColName":	{
		"prefix":	"üîê  BlockFunc.XTAB.TryGetNmbValByColName",
		"description":	["Bestimmten Wert (standardm√§ssig unter Einbezug einer allf√§lligen View) als Zahl abholen. Wenn Casting nicht m√∂glich ist, wird 0.0 zur√ºckgegeben. Standardm√§ssig Fehler, wenn adressierter Wert nicht vorhanden ist. Wenn dieser Fehler unterdr√ºckt wird, wird 0.0 geliefert."],
		"body":	[
			"\tvar ${1:numberVal} := XTAB.TryGetNmbValByColName(${2:xTabName}, ${3:colName}, ${4:oneBasedRowNo}, ${5:withoutView}, ${6:suppressExceptionIfNotAvailable})",		]
	},
	"BLOCKFUNC: XTAB.TryGetStrVal":	{
		"prefix":	"üîê  BlockFunc.XTAB.TryGetStrVal",
		"description":	["Bestimmten Wert (standardm√§ssig unter Einbezug einer allf√§lligen View) als String abholen. Wenn Casting nicht m√∂glich ist, wird '' (Leerstring) zur√ºckgegeben. Standardm√§ssig Fehler, wenn adressierter Wert nicht vorhanden ist. Wenn dieser Fehler unterdr√ºckt wird, wird '' (Leerstring) geliefert."],
		"body":	[
			"\tvar ${1:stringVal} := XTAB.TryGetStrVal(${2:xTabName}, ${3:oneBasedColNo}, ${4:oneBasedRowNo}, ${5:withoutView}, ${6:suppressExceptionIfNotAvailable})",		]
	},
	"BLOCKFUNC: XTAB.TryGetStrValByColName":	{
		"prefix":	"üîê  BlockFunc.XTAB.TryGetStrValByColName",
		"description":	["Bestimmten Wert (standardm√§ssig unter Einbezug einer allf√§lligen View) als String abholen. Wenn Casting nicht m√∂glich ist, wird '' (Leerstring) zur√ºckgegeben. Standardm√§ssig Fehler, wenn adressierter Wert nicht vorhanden ist. Wenn dieser Fehler unterdr√ºckt wird, wird '' (Leerstring) geliefert."],
		"body":	[
			"\tvar ${1:stringVal} := XTAB.TryGetStrValByColName(${2:xTabName}, ${3:colName}, ${4:oneBasedRowNo}, ${5:withoutView}, ${6:suppressExceptionIfNotAvailable})",		]
	},
	"BLOCKFUNC: XTAB.TrySetVal":	{
		"prefix":	"üîê  BlockFunc.XTAB.TrySetVal",
		"description":	["Einen Wert falls m√∂glich setzen (standardm√§ssig unter Einbezug einer allf√§lligen View). Im Constraint-Violation-Fehlerfall (√ºblicherweise Unique-Index-Verletzung) wird Wert nicht gesetzt. Im Casting-Fehlerfall (√ºbergebener Wert passt nicht zur adressierten Spalte und kann auch nicht umgewandelt werden) wird Wert nicht gesetzt. R√ºckgabewert besagt, ob Wert gesetzt wurde oder nicht. Standardm√§ssig Fehler, wenn Spalte oder Zeile nicht existiert."],
		"body":	[
			"\tvar ${1:boolVal} := XTAB.TrySetVal(${2:xTabName}, ${3:oneBasedColNo}, ${4:oneBasedRowNo}, ${5:value}, ${6:withoutView}, ${7:suppressExceptionIfNotAvailable})",		]
	},
	"BLOCKFUNC: XTAB.TrySetValByColName":	{
		"prefix":	"üîê  BlockFunc.XTAB.TrySetValByColName",
		"description":	["Einen Wert falls m√∂glich setzen (standardm√§ssig unter Einbezug einer allf√§lligen View). Im Constraint-Violation-Fehlerfall (√ºblicherweise Unique-Index-Verletzung) wird Wert nicht gesetzt. Im Casting-Fehlerfall (√ºbergebener Wert passt nicht zur adressierten Spalte und kann auch nicht umgewandelt werden) wird Wert nicht gesetzt. R√ºckgabewert besagt, ob Wert gesetzt wurde oder nicht. Standardm√§ssig Fehler, wenn Spalte oder Zeile nicht existiert."],
		"body":	[
			"\tvar ${1:boolVal} := XTAB.TrySetValByColName(${2:xTabName}, ${3:colName}, ${4:oneBasedRowNo}, ${5:value}, ${6:withoutView}, ${7:suppressExceptionIfNotAvailable})",		]
	},
}
